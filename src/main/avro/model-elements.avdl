/**
 * Copyright (c) 2012 The Regents of the University of California.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

@namespace("edu.berkeley.path.model_elements_base")

// ## TODO use imports to break up this file:
// ## import idl "foo.avdl";
// ## import schema "foo.avsc";

/** 
 * Description of the config and state of our networks and related data.
 *
 * Note: all units in SI (meters, seconds, etc.) except where specified.
 */
protocol CC {
  
  /** milliseconds, absolute, since epoch, utc */
  record DateTime {
    long milliseconds;
  }
  
  /** milliseconds */
  record Duration {
    long milliseconds;
  }
  
  record Node {
    string id;
    string name;
    string type;
  }
  
  record Link {
    string id;
    string name;
    string type;
    
    union { null, double } laneCount;
    union { null, double } length;
    
    /**
     * index of the first lane of this link in case the road is
     * divided into paralell links.
     */
    union { null, int } laneOffset;
    union { null, double } speedLimit;
    union { null, int } detailLevel;

    string beginId;
    string endId;
  }

  record Network {
    string id;
    string name;
    union { null, string } description;
    union { null, string } projectId;

    array<Node> nodes = [];
    array<Link> links = [];
  }
  
  /**
   * Density on each link at a point in time
   */
  record DensityMap {
    /** map key is linkId */
    map<double> vehiclesPerMeter = {};
    // ## should this break down by destinationNetworkId and vehTypeId ?
  }
  
  record DensitySet {
    string id;
    string name;
    union { null, string } description;
    union { null, string } projectId;
    
    DensityMap density;
  }
  
  /**
   * Velocity on each link at a point in time
   */
  record VelocityMap {
    /** map key is linkId */
    map<double> metersPerSecond = {};
    // ## should this break down by destinationNetworkId and vehTypeId ?
  }
  
  record VelocitySet {
    string id;
    string name;
    union { null, string } description;
    union { null, string } projectId;
    
    VelocityMap velocity;
  }
  
  /**
   * Referenced by FDSet to indicate the way the contained FDs should
   * be interpreted.
   */
  record FDType {
    string id;
    union {null, string} name;
    union {null, string} description;
  }
  
  /**
   * Fundamental diagram parameters on one link at one time.
   * Flow and density values are per lane in SI units.
   */
  record FD {
    union {null, double} freeFlowSpeed;
    union {null, double} criticalSpeed;
    union {null, double} congestionWaveSpeed;
    union {null, double} capacity;
    union {null, double} jamDensity;
    union {null, double} capacityDrop;
    union {null, double} freeFlowSpeedStd;
    union {null, double} congestionWaveSpeedStd;
    union {null, double} capacityStd;
  }
  
  /**
   * FD time series at a link. The link ID is not stored
   * in this record, but as the map key in the FDSet.profile.
   */
  record FDProfile {
    /**
     * in seconds; default is 0
     */
    union {null, double} startTime = 0.0;
    
    /**
     * in seconds; default is 300 seconds
     */
    union {null, double} sampleRate = 300.0;

    /**
     * time series of FDs;
     * array index is index in time series ("DIAG_ORDER" in db)
     */
    array<FD> fd;
  }

  /**
   * Specification of Fundamental diagram time series across one or more
   * networks, for use in a scenario.
   */
  record FDSet {
    string id;
    union {null, string} name;
    union {null, string} description;
    union { null, string } projectId;
    
    FDType type;
    
    /**
     * map key is linkId
     */
    map<FDProfile> profile;
  }
  
  /**
   * Used to feed a per-timestep "drip" input to freeway model.
   * This is sliced off of FDSet at a given time.
   *
   * Not part of Scenario; can be used interchangeably for
   * real-time input or for sliced up profiles from a scenario.
   */
  record FDMap {
    /**
     * map of FDs at a given time;
     * map key is linkId
     */
    map<FD> fd;
  }

  /**
   * Demand time series at a link. The origin link ID is not stored
   * in this record, but as the map key in the DemandSet.profile.
   */
  record DemandProfile {
    /**
     * if null, this profile governs background flow, not OD flow.
     */
    union {null, string} destinationNetworkId;

    /**
     * in seconds; default is 0
     */
    union {null, double} startTime = 0.0;
    
    /**
     * in seconds; default is 300 seconds
     */
    union {null, double} sampleRate = 300.0;
    
    /**
     * demand scale factor
     */
    union {null, double} knob = 1.0;
    
    union {null, double} stdDevAdd = 0.0;
    
    union {null, double} stdDevMult = 1.0;
    
    /**
     * time series of flows;
     * map keys is vehTypeId;
     * array index is index in time series ("DEMAND_ORDER" in db)
     */
    map<array<double>> flow;
  }
  
  /**
   * Specification of demand time series across one or more networks,
   * for use in a scenario.
   */
  record DemandSet {
    string id;
    union {null, string} name;
    union {null, string} description;
    union { null, string } projectId;
    
    /**
     * map key is originLinkId
     */
    map<DemandProfile> profile;
  }
  
  /**
   * Used to feed a per-timestep "drip" input to freeway model.
   * This is sliced off of DemandSet at a given time.
   *
   * Not part of Scenario; can be used interchangeably for 
   * real-time input or for sliced up profiles from a scenario.
   */
  record DemandMap {
    /**
     * map of flows at a given time;
     * map keys are: originLinkId, vehTypeId;
     */
    map<map<double>> flow;
    
    // ## does this need destinationNetworkId as another map key?
  }

  /**
   * Split ratio time series at a node. The node ID is not stored
   * in this record, but as the map key in the SplitRatioSet.profile.
   */
  record SplitRatioProfile {
    /**
     * if null, this profile governs background flow, not OD flow.
     */
    union {null, string} destinationNetworkId;

    /**
     * in seconds; default is 0
     */
    union {null, double} startTime = 0.0;
    
    /**
     * in seconds; default is 300 seconds
     */
    union {null, double} sampleRate = 300.0;
    
    /**
     * time series of ratios;
     * map keys are: inLinkId, outLinkId, vehTypeId;
     * array index is index in time series ("RATIO_ORDER" in db)
     */
    map<map<map<array<double>>>> ratio;
  }
  
  /**
   * Specification of split ratio time series across one or more networks,
   * for use in a scenario.
   */
  record SplitRatioSet {
    string id;
    union {null, string} name;
    union {null, string} description;
    union { null, string } projectId;
    
    /**
     * map key is nodeId
     */
    map<SplitRatioProfile> profile;
  }
  
  /**
   * Used to feed a per-timestep "drip" input to freeway model.
   * This is sliced off of SplitRatioSet at a given time.
   *
   * Not part of Scenario; can be used interchangeably for 
   * real-time input or for sliced up profiles from a scenario.
   */
  record SplitRatioMap {
    /**
     * map of ratios at a given time;
     * map keys are: nodeId, inLinkId, outLinkId, vehTypeId;
     */
    map<map<map<map<double>>>> ratio;
    
    // ## does this need destinationNetworkId as another map key?
  }

  /**
   * Sensor that can describe loop detector, magnetic detector, TMC, camera, radar, etc.
   */
  record Sensor {
    string type; // "Loop", etc
    union {null, string} entity_id;  // ID of original detector, e.g. VDS ID
    union {null, string} measurement_feed_id; // data feed associated with this sensor
    string link_id; // ### todo: camel case for consistency
    double link_offset = 0;
    double lane_num = 1;
    double health_status = 1; // healthy by default
  }

  /**
   * Set of sensors residing on links in potentially multiple networks.
   */
  record SensorSet {
    string id;
    union {null, string} name;
    union {null, string} description;

    union { null, string } projectId;
    
    array<Sensor> sensors;
  }
   
  
  // ### TODO Controllers
  
  record Project {
    string id;
    string name;
    union { null, string } description;
  }
  
  /**
   * A scenario represents the state of the world now and projected
   * into the future, to the extent that can be known in advance.
   *
   * The configuration that belongs in a scenario and the objects that it
   * contains are just those parameters that make an assertion about the 
   * world, an assertion which is observable, and verifiable. So, for example,
   * choice of CTM algorithm does not belong here, but FD parameters do,
   * and signal control algorithms do. (The CTM choice should be in the
   * Context.)
   */
  record Scenario {
    string id;
    string name;
    union { null, string } description;
    union { null, string } projectId;
    
    array<Network> networks = [];
    
    DensitySet initialDensity = null;
    VelocitySet initialVelocity = null;
    FDSet fdSet = null;
    DemandSet demandSet = null;
    SplitRatioSet splitratioSet = null;
    SensorSet sensorSet = null;
  }
  
  /**
   * Context and Run Config section
   *
   * Configuration that applies to one run or a group of runs.
   *
   * These objects correspond to the TBD Run tables.
   */
  
  record EnKFParams {
    double confidenceDefault;
    double confidenceHasMeasurement;
    double confidenceNoMeasurement;
    double confidenceMeasurementLifetime;
    double localizationDistance;
    boolean useLocalization;
    double modelNoiseMean;
    double modelNoiseStdev;
    double navteqNoiseMean;
    double navteqNoiseStdev;
    double navteqPercentage;
    array<int> PemsBlackList;
    double pemsNoiseMean;
    double pemsNoiseStdev;
    double telenavNoiseMean;
    double telenavNoiseStdev;
    double telenavPercentage;
  }
  
  /**
   * Encapsulates a single run of a process.
   */
  record ProcessConfig {
    string        host;
    long          pid;
    
    /** Note: wall clock time on host, not world time or sim time */
    DateTime      timeBegin;
    DateTime      timeEnd;
  }
  
  /**
   * Represents a single execution of the freeway model.
   *
   * Parameters here supplement the Context config with additional per-run
   * config.
   *
   * The FreewayRun id should be in one-to-one correspondence with actual
   * process executions on a host. If you run again with the same parameters
   * then the id should be different. Output data references this id.
   */
  record FreewayEstimationRunConfig {
    string        id;
    string        name;
    
    /** Refers to the FreewayContext for this run (among others) */
    string        contextId;
    
    // to add?
    // ensemble ID?
    
    array<long>   seeds;
    
    ProcessConfig process; 
  }
  
  record FreewayForecastRunConfig {
    string        id;
    string        name;
    
    /** Refers to the FreewayContext for this run (among others) */
    string        contextId;
    
    array<long>   seeds;
    
    ProcessConfig process; 
  }

  record SimulationRunConfig {
    string        id;
    string        name;
  }
  
  record CalibrationRunConfig {
    string        id;
    string        name;
  }
  
  record ImputationRunConfig {
    string        id;
    string        name;
  }

  /**
   * State of one link at one time.
   *
   * May contain density, velocity, or both.
   */
  record FreewayLinkState {
    union { double, null } density;
    union { double, null } velocity;
  }
  
  /**
   * In- and out-flow state of one link at one time.
   *
   * The in- and out-flows are a quantity of interest computed by a CTM,
   * though not needed for either estimation of future time steps of a CTM.
   */
  record FreewayLinkFlowState {
    double inFlow;
    double outFlow;
  }

  /**
   * State of entire CTM, comprising:
   * state of each link,
   * state of each origin queue, and
   * optionally the in- and out-flows of each link.
   */
  record FreewayCTMState {
    /** map key is link id */
    map<FreewayLinkState> linkState;
    
    /** map key is origin link id */
    map<double> queueLength;
    
    /** map key is link id */
    union {null, map<FreewayLinkFlowState>} linkFlowState;
  }

  /**
   * State of ensemble CTMs in an ordered list.
   */
  record FreewayCTMEnsembleState {
    /** one entry per CTM */
    array<FreewayCTMState> ensembleState;
    
    DateTime t; // ## rename "time" for consistency
    
    /** map key is link id
     *
     * used by FreewayReporterBlock? */
    union {null, map<double>} quality;
    // ### TODO call this confidence?
  }
  
  record FreewayCTMReport {
    long runID;
    
    /** Model time, of course */
    DateTime time;
    
    FreewayCTMState mean;
    FreewayCTMState stdDev;
    FDMap fd;
    
    /* whether this is a full report including flow stats (after a CTM step),
     * or not (after an EnKF step)
     */
    boolean includesFlows;
}
  
  record FreewayCTMEnsembleReport {
    long runID;
    FreewayCTMEnsembleState ensembleState;
  }
  
  /**
   * PeMS sensor datum as output by PeMS filter, for a specific
   * station and time.
   */
  record PeMS {
    long vdsId;
    DateTime timeMeasured;
    union { double, null } flow;
    union { double, null } density;
    union { double, null } densityError;
    union { double, null } speed;
    union { double, null } speedError;
    union { double, null } freeFlowSpeed;
    union { double, null } funcLoopFact;
    array<union { double, null }> gFactorLane;
  }
  
  /**
   * PeMS sensor data map, organized by VDS.
   */
  record PeMSMap {
    /**
     * Key is VDS id. Represents the state of the sensors at
     * one point in time.
     */
    map<PeMS> pems;
  }

  /**
   * PeMS sensor data profile. Represents the time history of
   * one sensor.
   */
  record PeMSProfile {
    array<PeMS> pems;
  }

  /**
   * PeMS sensor data set, organized as a time-series
   * of maps. This makes sense because filtered pems data
   * is generated at multiples of 30 seconds: 00:00, 00:30, ...
   */
  record PeMSSet {
    array<PeMSMap> pemsMap;
  }

  /**
   * PeMS sensor (the VDS station info, rather than the sensor data).
   */
  record PeMSStation {
    long      Id; // ### should be id
    int       fwyNum;
    string    direction;
    int       district;
    string    county;
    string    city;
    double    statePostmile;
    double    absPostmile;
    double    latitude;
    double    longitude;
    double    detectorLength;
    string    detectorType;
    string    detectorName;
    int       laneCount;
    
    array<string> userId;
    // ## TODO geom
  }
  
  /**
   * Used in both the 5 minute and 1 hour case for per-lane
   * and per-station aggregated data, and in the 1 day case
   * for per-station aggregated data.
   **/
  record PeMSAggregate {
    union { long, null }    samples;
    union { double, null }  flow;
    union { double, null }  avgOccupancy;
    union { double, null }  avgSpeed;
    union { double, null }  observed;
  }
  
  /**
   * Represents both the 5 minute and 1 hour aggregated data. If delay map
   * is present, then it represents a daily aggregate.
   **/
  record PeMSStationAggregate {
    long vdsId;
    DateTime timeMeasured;
    
    /**
     * Aggregated at this station, across lanes.
     **/
    PeMSAggregate total;
    
    /**
     * Aggregated by lane at this station.
     * Field is null for 1 day aggregates.
     **/
    union { array<PeMSAggregate>, null } byLane;
    
    /**
     * Average delay over the station length, for a threshold speed.
     * Keys are speeds in mph: "35", "40", ... "60".
     * Field is null for 5 minute aggregates.
     **/
    union { map<double>, null } delay;
  }
  
  /**
   * Static configuration of a set of freeway runs.
   *
   * The parameters encapsulated here are separate from Scenario inputs
   * in that they express *how* the run is modeled and executed,
   * rather than *what* is modeled.
   *
   * These parameters are used by the Context subclasses.
   *
   * Note that a context does not include a scenario. Scenarios are read
   * dynamically using a ScenarioSource.
   */
  record FreewayContextConfig {
    string        id;
    string        name;

    /**
     * historical, live
     **/
    string        runMode;
    
    /**
     * forecast, estimation
     **/
    string        workflow;
    
    /**
    * probea, probeb, pems
    **/
    string        feed;

    string        ctmType;
    int           ensembleSize;
    string        fdType;
    double        additiveModelNoiseMean;
    double        additiveModelNoiseStdDev;
    double        initialDensityFraction;    
    
    string        enkfType;
    EnKFParams    enkfParams;
    
    Duration      dtOutput;
    Duration      dt;
    
    DateTime      timeBegin;
    DateTime      timeEnd;
    
    SensorSet     sensorSet;
    
    // initial condition: specify either a single state, a whole ensemble, or none
    union {null, FreewayCTMEnsembleState}     initialEnsembleState;
    union {null, FreewayCTMState}             initialState;
    // additive noise to apply to the initial state ensemble
    double                                    initialStateUncertainty = 0.0;
  }

}
